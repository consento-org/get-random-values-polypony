#!/usr/bin/env node
const wd = require('wd')
const { logExec } = require('./lib/exec.js')
const { execSync } = require('child_process')
const del = require('del')
const path = require('path')
const ngrok = require('ngrok')
const { fetch, Headers } = require('cross-fetch')
const FormData = require('form-data')
const { createServer } = require('http')
const { createReadStream } = require('fs')
const { writeFile, mkdir, readFile } = require('fs').promises
const package = require('../package.json')

/*
function mergeIterators (streams) {
  let iterators
  const list = {
    next: undefined,
    last: undefined
  }
  let next
  return {
    next () {
      if (iterators === undefined) {
        iterators = new Map()
        for (const stream of streams) {
          const iter = stream[Symbol.asyncIterator]()
          iterators.set(stream, iter)
          iter.next()
        }
      }
      if (list.next) {
        let result = list.next
        list.next = result.next
        if (list.next === undefined) {
          list.last = undefined
        }
        return result.promise
      }
      return new Promise((resolve, reject) => {
        next = { resolve, reject }
      })
    },
    return () {}
  }
}
*/

const createServerAsync = function (listener, port) {
  return new Promise((resolve, reject) => {
    const server = createServer(listener)
    const close = () => {
      return new Promise((resolve) => {
        server.once('close', resolve)
        server.close()
      })
    }
    const finish = (error) => {
      server.removeListener('error', finish)
      server.removeListener('listening', finish)
      if (error instanceof Error) {
        reject(error)
      } else {
        resolve({ server, close })
      }
    }
    server.once('error', finish)
    server.once('listening', finish)
    server.listen(port)
  })
}

;(async () => {
  const bs = {
    user: process.env.BROWSERSTACK_USER,
    key: process.env.BROWSERSTACK_ACCESS_KEY
  }
  const browserStack = bs.user !== undefined
  const system = process.argv[2]
  const android = system === 'android'

  if (!android && process.argv[2] !== 'ios') {
    throw new Error('First argument needs to be "ios" or "android"')
  }

  // const ios = system === 'ios' // Unused at the moment, maybe useful at other times

  const runId = process.env.GITHUB_RUN_ID || 'dirty'

  let device = process.env.BROWSERSTACK_DEVICE
  if (!device) {
    if (android) {
      device = 'Google Pixel 3'
    } else {
      device = 'iPhone XS'
    }
  }
  
  let os_version = process.env.BROWSERSTACK_OS_VERSION
  if (!os_version) {
    if (android) {
      os_version = '9.0'
    } else {
      os_version = '12'
    }
  }

  const build = `${runId}:react-native:${system}:${device}:${os_version}`
  console.log(`## Running ${browserStack ? 'browser-stack' : 'local'} build â†’ ${build}`)
  let _resolve
  let _reject
  const response = new Promise((resolve, reject) => {
    _resolve = resolve
    _reject = reject
  })
  const target = `${__dirname}/rntape/node_modules/${package.name}`
  try {
    await del(target)
    console.log(`## react-native:clearing-old-dep [target=${target}]`)
  } catch (err) {
    if (err.code !== 'ENOTDIR') {
      throw err
    }
  }
  console.log(`## react-native:npm install`)
  const rnPkg = require(`${__dirname}/rntape/package.json`)
  delete rnPkg.dependencies[package.name]
  await writeFile(`${__dirname}/rntape/package.json`, JSON.stringify(rnPkg, null, 2) + '\n')
  try {
    await logExec('npm', ['i'], { cwd: `${__dirname}/rntape` })
  } finally {
    rnPkg.dependencies[package.name] = ''
    await writeFile(`${__dirname}/rntape/package.json`, JSON.stringify(rnPkg, null, 2) + '\n')
  }
  console.log(`## react-native:preparing-dep [target=${target}]`)
  await mkdir(path.dirname(target), { recursive: true })
  console.log(`## react-native:copy-build [src=./dist target=${target}]`)
  await execSync(`cp -r ${__dirname}/../dist ${target}`)
  console.log("## local-server:start")
  const { server, close } = await createServerAsync((req, res) => {
    const result = []
    req.on('data', data => result.push(data))
    req.on('error', (error) => {
      console.error(error)
      res.end('fail')
    })
    req.on('end', () => {
      _resolve(JSON.parse(Buffer.concat(result).toString()))
      res.end('ok')
    })
  }, 1234)
  let driver
  try {
  console.log("## ngrok:connect")
    const publicURL = await ngrok.connect({
      proto: 'http',
      region: process.env.NGROK_REGION,
      addr: server.address().port
    })
    console.log(`## ngrok:connected [publicURL=${publicURL}]`)
    console.log('## react-native:build:prepare')
    await writeFile(
      `${__dirname}/rntape/test.json`,
      JSON.stringify({
        publicURL
      }, null, 2)
    )
    let buildDetails
    if (android) {
      console.log('## react-native:build:android')
      await logExec('./gradlew', ['assembleRelease'], { cwd: `${__dirname}/rntape/android` })
      buildDetails = {
        app: `${__dirname}/rntape/android/app/build/outputs/apk/release/app-release.apk`,
        capabilities: {
          device,
          os_version
        }
      }
      // execSync('react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/')
    } else {
      console.log('## react-native:build:ios:pod')
      await logExec('pod', ['install', '--clean-install'], { cwd: `${__dirname}/rntape/ios` })
      console.log('## react-native:build:ios:app')
      console.log(execSync(`mkdir -p ${__dirname}/rntape/ios/build`).toString())
      await logExec(
        'xcodebuild',
        [
          'clean',
          'build',
          '-workspace', `${__dirname}/rntape/ios/rntape.xcworkspace`,
          '-configuration', 'Release',
          '-scheme', 'rntape',
          '-arch', 'arm64',
          '-derivedDataPath', 'build',
          'CODE_SIGN_IDENTITY=""',
          'CODE_SIGNING_REQUIRED="NO"',
          'CODE_SIGN_ENTITLEMENTS=""',
          'CODE_SIGNING_ALLOWED="NO"'
        ],
        { cwd: `${__dirname}/rntape/ios` }
      )
      console.log('## react-native:build:ios:ipa')
      await logExec('rm', ['-r', 'ipa'], { cwd: `${__dirname}/rntape/ios/build` })
      await logExec('mkdir', ['-p', 'build/ipa/Payload'], { cwd: `${__dirname}/rntape/ios` })
      await logExec('cp', ['-r', 'build/Build/Products/Release-iphoneos/rntape.app', 'build/ipa/Payload/rntape.app'], { cwd: `${__dirname}/rntape/ios` })
      await logExec('rm', ['rntape-1.ipa'], { cwd: `${__dirname}/rntape/ios/build` })
      await logExec('zip', ['-r', '../rntape-1.ipa', 'Payload'], { cwd: `${__dirname}/rntape/ios/build/ipa` })
      buildDetails = {
        app: `${__dirname}/rntape/ios/build/rntape-1.ipa`,
        capabilities: {
          device,
          os_version
        }
      }
    }
    if (browserStack) {
      const formData = new FormData()
      formData.append('file', createReadStream(buildDetails.app))
      formData.append('data', '{}')
      const headers = new Headers(formData.getHeaders())
      headers.append('Authorization', 'Basic ' + Buffer.from(bs.user + ":" + bs.key).toString('base64'))
      console.log('## Uploading file to browserstack')
      const json = await (await fetch(`https://api-cloud.browserstack.com/app-automate/upload`, {
        method: 'post',
        body: formData,
        headers
      })).json()

      if (json.error) {
        throw new Error(json.error)
      }

      const { app_url } = json

      console.log(`## Starting browser test at ${app_url}`)
  
      driver = wd.promiseRemote("http://hub-cloud.browserstack.com/wd/hub")

      const caps = {
        ...buildDetails.capabilities,
        'browserstack.user': bs.user,
        'browserstack.key': bs.key,
        'browserstack.networkLogs': true,
        project: package.name,
        build,
        name: package.name,
        app: app_url
      }

      console.log({ caps })

      process.on('uncaughtException', _reject)
      driver
        .init(caps)
        .fin(function() {})
        .done()
    } else {
      if (android) {
        console.log('## react-native:install')
        await logExec('adb', ['install', '-r', 'app/build/outputs/apk/release/app-release.apk'], { cwd: `${__dirname}/rntape/android` })
        console.log('## MANUAL ACTION REQUIRED: open the react-native app "rntape" on the device.')
      } else {

      }
    }
    // TODO use ./rntape/android/app/build/android-sourcemap.js for good error messages
    console.log((await response).output)
  } catch (err) {
    if (err.data) {
      err.message = err.message + '\n' + err.data
    }
    throw err
  } finally {
    process.removeListener('uncaughtException', _reject)
    driver && driver.quit()
    console.log('## ngrok:disconnect')
    await ngrok.disconnect()
    await ngrok.kill()
    console.log('## server:close')
    await close()
  }
  return response
})()
  .then(
    ({finished}) => {
      process.exit(finished)
    },
    err => {
      console.error(err.stack)
      process.exit(2)
    }
  )

