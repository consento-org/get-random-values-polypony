#!/usr/bin/env node
const wd = require('wd')
const { logExec,exec } = require('./lib/exec.js')
const { execSync } = require('child_process')
const del = require('del')
const path = require('path')
const ngrok = require('ngrok')
const { fetch, Headers } = require('cross-fetch')
const FormData = require('form-data')
const { createServer } = require('http')
const { createReadStream } = require('fs')
const { writeFile, mkdir } = require('fs').promises
const package = require('../package.json')

async function parseExpoBuild (command, args, opts) {
  let build
  for await (const line of exec(command, args, opts)) {
    const parts = /builds\/([0-9a-f-]+)/ig.exec(line)
    if (parts) {
      build = parts[1]
    }
    console.log(line)
  }
  return build
}

/*
function mergeIterators (streams) {
  let iterators
  const list = {
    next: undefined,
    last: undefined
  }
  let next
  return {
    next () {
      if (iterators === undefined) {
        iterators = new Map()
        for (const stream of streams) {
          const iter = stream[Symbol.asyncIterator]()
          iterators.set(stream, iter)
          iter.next()
        }
      }
      if (list.next) {
        let result = list.next
        list.next = result.next
        if (list.next === undefined) {
          list.last = undefined
        }
        return result.promise
      }
      return new Promise((resolve, reject) => {
        next = { resolve, reject }
      })
    },
    return () {}
  }
}
*/

const createServerAsync = function (listener, port) {
  return new Promise((resolve, reject) => {
    const server = createServer(listener)
    const close = () => {
      return new Promise((resolve) => {
        server.once('close', resolve)
        server.close()
      })
    }
    const finish = (error) => {
      server.removeListener('error', finish)
      server.removeListener('listening', finish)
      if (error instanceof Error) {
        reject(error)
      } else {
        resolve({ server, close })
      }
    }
    server.once('error', finish)
    server.once('listening', finish)
    server.listen(port)
  })
}

;(async () => {
  const bs = {
    user: process.env.BROWSERSTACK_USER,
    key: process.env.BROWSERSTACK_ACCESS_KEY
  }
  const browserStack = bs.user !== undefined
  const system = process.argv[2]
  const android = system === 'android'
  const ios = system === 'ios'
  const expo = system === 'expo'

  if (!android && !ios && !expo) {
    throw new Error('First argument needs to be "ios" or "android" or "expo"')
  }

  const runId = process.env.GITHUB_RUN_ID || 'dirty'

  let device = process.env.BROWSERSTACK_DEVICE
  if (!device) {
    if (!ios) {
      device = 'Google Pixel 3'
    } else {
      device = 'iPhone XS'
    }
  }
  
  let os_version = process.env.BROWSERSTACK_OS_VERSION
  if (!os_version) {
    if (!ios) {
      os_version = '9.0'
    } else {
      os_version = '12'
    }
  }

  const build = `${runId}:react-native:${system}:${device}:${os_version}`
  console.log(`## Running ${browserStack ? 'browser-stack' : 'local'} build â†’ ${build}`)
  let _resolve
  let _reject
  const response = new Promise((resolve, reject) => {
    _resolve = resolve
    _reject = reject
  })
  const root = `${__dirname }/${expo ? 'expotape' : 'rntape'}`
  const target = `${root}/node_modules/${package.name}`
  try {
    await del(target)
    console.log(`## react-native:clearing-old-dep [target=${target}]`)
  } catch (err) {
    if (err.code !== 'ENOTDIR') {
      throw err
    }
  }
  console.log(`## react-native:npm install`)
  const rnPkg = require(`${root}/package.json`)
  delete rnPkg.dependencies[package.name]
  await writeFile(`${root}/package.json`, JSON.stringify(rnPkg, null, 2) + '\n')
  try {
    await logExec('npm', ['i'], { cwd: `${root}` })
  } finally {
    rnPkg.dependencies[package.name] = ''
    await writeFile(`${root}/package.json`, JSON.stringify(rnPkg, null, 2) + '\n')
  }
  console.log(`## react-native:preparing-dep [target=${target}]`)
  await mkdir(path.dirname(target), { recursive: true })
  console.log(`## react-native:copy-build [src=./dist target=${target}]`)
  execSync(`cp -r ${__dirname}/../dist ${target}`)
  console.log("## local-server:start")
  const { server, close } = await createServerAsync((req, res) => {
    const result = []
    req.on('data', data => result.push(data))
    req.on('error', (error) => {
      console.error(error)
      res.end('fail')
    })
    req.on('end', () => {
      _resolve(JSON.parse(Buffer.concat(result).toString()))
      res.end('ok')
    })
  }, 1234)
  let driver
  try {
  console.log("## ngrok:connect")
    const publicURL = await ngrok.connect({
      proto: 'http',
      region: process.env.NGROK_REGION,
      addr: server.address().port
    })
    console.log(`## ngrok:connected [publicURL=${publicURL}]`)
    console.log('## react-native:build:prepare')
    await writeFile(
      `${root}/test.json`,
      JSON.stringify({
        publicURL
      }, null, 2)
    )
    let buildDetails
    if (android) {
      console.log('## react-native:build:android')
      await logExec('./gradlew', ['assembleRelease'], { cwd: `${root}/android` })
      buildDetails = {
        app: `${root}/android/app/build/outputs/apk/release/app-release.apk`,
        capabilities: {
          device,
          os_version
        }
      }
    }
    if (expo) {
      console.log('## react-native:build:expo')
      const build = await parseExpoBuild('npx', ['expo', 'build:android', '-t', 'apk', '--no-publish', '--non-interactive'], { cwd: root })
      console.log({ build })
      const apk = (await exec('node', ['-e', `
        const xdl = require('@expo/xdl');
        xdl.Project.getBuildStatusAsync(
          '.',
          { platform: 'android', current: false }
        ).then(
          data =>
            console.log(
              data.jobs?.filter(job => job.id === 'cf1ac83d-94a8-4570-804b-29cb184d4466')[0]?.artifacts.url
            )
        )
      `], { cwd: root }).promise()).trim()
      console.log({ apk })
      buildDetails = {
        appUrl: apk,
        capabilities: {
          device,
          os_version
        }
      }
    }
    if (ios) {
      console.log('## react-native:build:ios:pod')
      await logExec('pod', ['install', '--clean-install'], { cwd: `${root}/ios` })
      console.log('## react-native:build:ios:app')
      console.log(execSync(`mkdir -p ${root}/ios/build`).toString())
      await logExec(
        'xcodebuild',
        [
          'clean',
          'build',
          '-workspace', `${root}/ios/rntape.xcworkspace`,
          '-configuration', 'Release',
          '-scheme', 'rntape',
          '-arch', 'arm64',
          '-derivedDataPath', 'build',
          'CODE_SIGN_IDENTITY=""',
          'CODE_SIGNING_REQUIRED="NO"',
          'CODE_SIGN_ENTITLEMENTS=""',
          'CODE_SIGNING_ALLOWED="NO"'
        ],
        { cwd: `${root}/ios` }
      )
      console.log('## react-native:build:ios:ipa')
      await logExec('rm', ['-rf', 'ipa'], { cwd: `${root}/ios/build` })
      await logExec('mkdir', ['-p', 'build/ipa/Payload'], { cwd: `${root}/ios` })
      await logExec('cp', ['-r', 'build/Build/Products/Release-iphoneos/rntape.app', 'build/ipa/Payload/rntape.app'], { cwd: `${root}/ios` })
      await logExec('rm', ['-f', 'rntape-1.ipa'], { cwd: `${root}/ios/build` })
      await logExec('zip', ['-r', '../rntape-1.ipa', 'Payload'], { cwd: `${root}/ios/build/ipa` })
      buildDetails = {
        app: `${root}/ios/build/rntape-1.ipa`,
        capabilities: {
          device,
          os_version
        }
      }
    }
    if (browserStack) {
      const formData = new FormData()
      if (buildDetails.app) {
        formData.append('file', createReadStream(buildDetails.app))
        formData.append('data', '{}')
      } else {
        formData.append('data', JSON.stringify({ url: buildDetails.appUrl }))
      }
      console.log({ formdData: formData.getBuffer().toString() })
      const headers = new Headers(formData.getHeaders())
      headers.append('Authorization', 'Basic ' + Buffer.from(bs.user + ":" + bs.key).toString('base64'))
      console.log('## Uploading file to browserstack')
      const json = await (await fetch(`https://api-cloud.browserstack.com/app-automate/upload`, {
        method: 'post',
        body: formData,
        headers
      })).json()

      if (json.error) {
        throw new Error(json.error)
      }

      const { app_url } = json

      console.log(`## Starting browser test at ${app_url}`)
  
      driver = wd.promiseRemote("http://hub-cloud.browserstack.com/wd/hub")

      const caps = {
        ...buildDetails.capabilities,
        'browserstack.user': bs.user,
        'browserstack.key': bs.key,
        'browserstack.networkLogs': true,
        project: package.name,
        build,
        name: package.name,
        app: app_url
      }

      console.log({ caps })

      process.on('uncaughtException', _reject)
      driver
        .init(caps)
        .fin(function() {})
        .done()
    } else {
      if (android) {
        console.log('## react-native:install')
        await logExec('adb', ['install', '-r', 'app/build/outputs/apk/release/app-release.apk'], { cwd: `${root}/android` })
        console.log('## MANUAL ACTION REQUIRED: open the react-native app "rntape" on the device.')
      } else {
        console.log('## MANUAL ACTION REQUIRED: Install the app and start it')
      }
      // TODO ios & expo local install
    }
    // TODO use ./rntape/android/app/build/android-sourcemap.js for good error messages
    console.log((await response).output)
  } catch (err) {
    if (err.data) {
      err.message = err.message + '\n' + err.data
    }
    throw err
  } finally {
    process.removeListener('uncaughtException', _reject)
    driver && driver.quit()
    console.log('## ngrok:disconnect')
    await ngrok.disconnect()
    await ngrok.kill()
    console.log('## server:close')
    await close()
  }
  return response
})()
  .then(
    ({finished}) => {
      process.exit(finished)
    },
    err => {
      console.error(err.stack)
      process.exit(2)
    }
  )

